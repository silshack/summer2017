---
layout: post
author: chall12
title: "Caroline's Final Project"
---

Here is an embedded link to my project: <iframe src="https://trinket.io/embed/python/f17d22c7e3" width="100%" height="600" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>



Creating a game of sharks and minnows was actually my first idea when the project was assigned. While initially, I had a general idea of what I wanted my program to accomplish, I was unsure of the exact steps to take or the code for how to get to the end result. I’ll run through my process in this reflection in the form of four main outlines for four differentiable chunks of code within my program. These four segments are 1- the initial screen setup, user turtle setup and user interface dialogue; 2- the creation of my three classes (Score, Coin, and Shark) and how they were created to move across the screen; 3- how these classes interact with the user’s fish turtle and how this affects the outcome of the game; and 4- my dictionary file save and what happens when the game is over.


When I began to brainstorm this project and outline what I wanted it to look like in my head, I honestly saw something that looks similar to what the final product actually is, which is extremely exciting for me! I began everything by coding the background screen with various coral species and then placed where I wanted the points turtle class to appear and the code that tells the user what level they are on. For the background, I chose light pastel colors so that the fish, sharks, and coins would stand out better on the screen. I started with grand ideas of having animated backgrounds that moved like a living coral reef, but quickly tossed this as I began to comprehend the amount of time and effort that the rest of the game would require to code. From here, I used the website, Piskel, which we learned about in class from Sam, to draw the user’s turtle fish, the sharks, and the coins, which I then uploaded and added to the screen. This was probably my favorite part of the assignment, as I thought it was extremely cool to be able to draw something in another interface, upload it, and then use it in a custom made game (the ultimate computer coding DIY). After moving the fish around some and losing it off the screen a few times, I realized that it would be smart to create Boolean expression that returned True or False as to whether or not the main fish was within the set screen boundaries that I created (I didn’t have a set screen size initially, but added it after noticing distortions when running the program in different window sizes with the Piskel shape uploaded). One of the next milestones that I worked on tackling was the user interface dialogue that can be toggled on and off the screen by pressing the ‘i’ key on the keyboard, which took a bit of time to figure out. To nail this part of the program down, I sat down with a piece of paper and wrote down sentences for each line of the code to make sense of the logic as I wrote it, which was extremely helpful.


The second portion of code proved to be one of the greatest challenges for me by far, as it required the creation and manipulation of three classes, which we just recently learned in class. I created the Coin and Shark classes first because they have similar methods and initial attributes. While I wanted the sharks and coins to appear to the right of the screen and then gradually move left to interact with the fish, I tested the game with the shark and coin coordinates with x values from 150 to 200 (on screen) to make sure that they appeared and moved the way I wanted them to. The y-values for the sharks and coins is assigned randomly (import random) between values of -200 and 200. This way, the user has no idea where the sharks will be coming from and the game will be different and interesting every time. When I first began this portion of the code, I struggled with making it so that multiple sharks and multiple coins were created simultaneously and were able to move at the same time. Erin, my paired partner for in class discussions, was extremely helpful for this as she suggested that I make a list of turtles so that I can create a function that acts on all of these turtles the same way. From this advice, I created a make_obj_list function that calls my Shark and Coin classes and appends them a specified number of times to a list. That number denotes how many sharks and coins are created, which comes into play later with my creation of multiple game levels with increasing difficulty. Making these objects move simultaneously across the screen was another portion of code that took me a while to figure out, which I had an imperfect solution for using my class’s ‘move’ methods and a ‘for’ loop. Because I was using a loop that stated “for i in range 100”, every action I tried to call afterwards, like the score keeping class function, was called 100 times (which obviously created awesome scores for the user, but wasn’t what I wanted). This Monday, we learned about recursive functions which resolved my need for the ‘for’ loop and helped me make further progress in my code regarding the coins and fish. Talking through code with Elliott over Google Hangouts was extremely helpful for the trickiest parts of this program, which occur in the third portion of code after the move method for my classes is called.


One of the primary hiccups that I faced was figuring out how to make it so that the code recognized the difference between sharks and coins after they had already been appended to my object list. I attempted breaking up the list into two different parts, but this changed the way that the objects moved across the screen. Talking to Elliott and learning about the ‘isinstance’ function solved this issue and allowed for me to separate the coins and the sharks after they had been moved to act upon them with other methods from their classes. From here, I worked on the two portions of code separately for if the fish intersects paths with a shark or a coin. The coin class is given the initial attribute of ‘item.available == True’. When the fish comes within a certain distance of the coin, the coin turtle is hidden, the attribute is turned to False and the function returns a False. From here, the Score class, which sums on intervals of 10 for the point tally when called, is called to keep tabs on the user’s score. I worked on creating levels that change depending on the player’s score below this code, which went smoothly other than when I tried to clear the object list that contained the shark and coin turtles. Before once again talking through things with Elliott, I was trying to reassign the variable name of the list to a new blank list, which didn’t work. Elliott reminded me of the ability to delete the contents of a list by using ‘del’, which solved that problem and enabled me to move on in my code and create some ‘elif’ statements for what should happen to the screen if different point values are reached. At 0 points, there are 20 sharks and 20 turtles and the screen reads ‘Level: 1’, then at 50 points the list deletes and the turtles reset and a new list of 50 sharks and 50 coins is populated to automatically move across the screen (Level 2). After the user reaches 100 points, the list repopulates for 75 sharks and coins (Level 3). After the user reaches 150 points, the win screen appears, the player has the option to click the screen to play again, and the file_save.player_entry function is called (I’ll talk about this more in a bit). If the user hits a shark then the lose screen is called and the player has the chance to click to play again (the file save is only available for the winners by my choice). Creating the win and lose screens was really fun because it was a chance for me to get more creative with my code. If the player loses, then “Game Over” prints across the screen and the user’s fish drifts slowly downwards as if it died. If the user wins then “You win!” is printed across the screen and the fish swims around the words in circles.


The final portion of code that I worked on was creating a dictionary that saves to a text file. I wanted the prompt for adding a new entry to the text file to be callable by a function. To write the code that I created, I used my Poetry Slam Files exercise and the Dictionary Broadcast code that we used in class, which helped me remember that to create a dictionary with user input as the key, it’s easiest to create a list that has inputs appended incrementally. This portion of code didn’t really cause me that much of a mental headache as some of the other segments of code.


I have extremely mixed feelings about this project when I reflect on working on it throughout this past week. The satisfaction that stems from making the project overshadows all of the frustration and dozens of hours spent pulling my hair out for not being able to figure out why certain portions of the code were not working. Breaking the code into smaller milestones was extremely helpful because it set reasonable expectations of what code would be completed at the end of the day. Towards the beginning of the project, I made my milestones too large and felt discouraged when I didn’t reach the goals I set for myself that day. Adjusting these goals and understanding my own capabilities in programming made a difference and helped me tackle problems from a better perspective (medium confidence coming into play?) I feel accomplished after making this game and have a newfound respect for people who code games regularly. Ultimately, as this class comes to an end, I feel more confident in my coding abilities and also feel more familiar with the coding community.
