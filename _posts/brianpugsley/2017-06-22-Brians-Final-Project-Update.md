---
layout: post
author: brianpugsley
title: "Brian's Final Final Project Update"
---

<iframe src="https://trinket.io/embed/python/a8acb99e28" width="100%" height="600" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>

- [X] Program draws roads, equally spaced
- [X] Program initiates with frog at bottom, middle of screen
- [X] Frog is able to move, one section at a time, in any direction.
- [X] Program won't allow frog to leave the screen
- [X] Program generates "win" when frog reaches other side of roads
- [X] Program has car turtles that drive on road
- [X] If frog/car intersect, "lose"
- [X] Program has multiple levels of difficulty
- [X] Difficulty based on speed/number of cars
- [X] Program displays level
- [X] New game option after completion
- [X] Game restart
- [X] Help option that is clickable or callable by pressing a key

Stretch
- [ ] Give the frog lives and have them displayed on the screen
- [ ] Score based on number of moves it takes to get to the other side
- [ ] Add 'flys' or some other thing the frog can collect for a score.


In starting this project, I was tempted to go the data analysis route. Especially after completing the blackjack project; however, the turtle project seemed more fun and interesting. When I began the project, I was feeling very overwhelmed with work, the assignments in my other classes, and some things going on in my personal life. With this, when I began on my first final turtle project, a hangman game, I made an extremely poor choice that I deeply, deeply regret and plagiarized code from a project that another student completed in a previous semester. There no reason I can give that makes this at all acceptable or excuses me from what I did. What I did was disrespectful, dishonest, and, dishonorable. In this class, Elliott has worked hard, along with every student in the class, to create an environment in which people feel welcome, included, and respected. In choosing to plagiarize, I disrespected this culture that was created and disrespected everyone in the class. Words cannot describe how much I regret this choice that I made. I have truly enjoyed this class and am extremely disappointed in myself for showing this lack of judgement right at the end. I have valued the interactions I have had with everyone, the help I have received when I have been struggling, and the support I see everyone provide when someone is having an issue with their code or in their life. For now, the only thing I can do is move forward with the understanding and conviction that this will never happen again. I understand that I will have to face the consequences of my decision and will do so with the honesty and respect this course/program/school deserves.
 
After discussing this with Elliott, he asked me to move on to brand-new project that was completely my own so, I began working on a Python turtle version of Frogger. When I began, I started by setting up some pretty achievable milestones. I wanted a screen that looked like a typical frogger scene (I decided to avoid the river sections of Frogger because of how complicated the coding might be though that was one of my stretch goals). So, I began by setting up the screen. This was relatively easy as I wanted things to be equidistant to allow for better interaction between the user and the interface. I used multiple for loops to create the road, the lines outlining the road, and the dashes down the middle of the road. Then began the challenging part.
 
I decided to bite off the easiest part first and get the frog turtle to show up on the screen and be able to move it. Initially, it took a bit of time just to get the frog the correct size that I wanted it to be and in the exact location I wanted it. This was important because, eventually, I wanted the frog to be able to hop across the road to get to the other side. Then, I just worked to be able to move the frog around using the arrow keys. Once I had that down, I setup the parameters of the movement. I wanted the frog to hop into each “lane” and be able to go in any direction. Once that was complete, I decided to limit where the frog could go. This allowed me to keep the frog from going off the screen. For the top and bottom, I just made it so the movement of the frog was reversed so it just ended up back where it started. For the sides, I wanted to allow the frog to hop back and forth between both sides of the screen so, when it goes past the edge of the right or left side of the screen, it jumps to the other side. 
 
After getting the frog to work with the movement and giving it the ability to stay inside the lanes/parameters I needed it to, I moved on to the car turtles. I was able to find some artwork that is freely licensed and open on the web. I loaded the turtles into Trinket and then put them in a list. I did this so there would be some variation in the colors of the cars that would, eventually, drive across the screen. I then created a class for the car turtles so I didn’t have to create them all manually. Initially, I had a move function within the class but, as I’ll discuss later, it did not work as I hoped it would. Inside the class, it makes a random choice of image to serve as the car turtle’s shape. Then, because I wanted to car turtles to drive in the lanes, I created a quick, clicky debug function that would print the x,y coordinates for me when I clicked. So I clicked where the lanes sat and noted the y-coordinates. Then, I made a list of those y-coordinates and set the position at the initiation of the car turtle class to an x-coordinate of either -205 or 205 and a y-coordinate of a random choice from the list. Setting the x-coordinate this way pushed the car turtle off the edge of the screen so you didn’t see it and, instead, it would just come from the edge and travel across. Initially, I could only have one car moving across the screen at a time which made the game quite easy. However, after discussing the def go() function that implemented screen.ontimer in class on Monday, the program would allow multiple cars to cross the screen at a time. The screen.ontimer did raise a few glitches for me though and, because we didn’t really review them in class, I’m still unsure what is going wrong or how to fix it. I will say that the glitches are workable within the program so it is still an enjoyable experience for the user. I found a solution to one of the glitches that kept running through the loop, even when the user reached the “goal”. That was fixed with a simple if statement.
 
After that, I was having some trouble with the intersection function so I moved on to create win and lose functions. For this, I knew I had to have a variable or dictionary and, for ease of design, I started with a simple variable, level_counter. I depended on this level counter to change the background, update the level display (which wasn’t working properly for a while), and initiate the win function. I started, first, on the win function. I used some if/elif/else statements inside of a for loop that looped through the same number of times as the number of levels to logically read the level_counter and determine what to do. I set the program to look at the level_counter and, if it was below 3, it would move through a set of functions to set the screen up for the next level. I used a check level function here to change the background color based on the value of the level_counter.
 
Where I placed the movement of the car turtles had a pretty significant effect on the success of my program. Initially, I put it in the class but I couldn’t get it to initiate properly. So, I took it out and put it inside of my screen.ontimer function. I implemented an intersection function inside here to so the program would check, every time it moved, whether it had intersected the turtle or not. 
 
Finally, I just went through and tried to make it more appealing/look nicer. I added a section at the top that would display the level. Initially, I had the level being displayed in a bottom corner but I couldn’t get the turtle to clear so it would just write “Level 1”, “Level 2”, and “Level 3” right on top of each other. This is when I switched from a variable to the dictionary. After watching the Game State Dictionary videos, I decided they were more easily managed and offered me some flexibility inside the program if I decided to add more functionality. For keys, I just used the Level and Moves Used. The level serves an obvious purpose and the Moves Used displays how many times the frog has moved and, in the future, could help with scoring. I also implemented a help function that could be called on a key press or on the click of a button and a reset button. However, I have been having difficulties with the reset button for some time and am not sure if it is a program error or an error that is being caused because I can’t get the car turtles to stop moving. I tried a quit function inside the loops and outside the loops but, no matter what I tried, I couldn’t get the car turtles to stop, even after the program stopped running. 
 
Throughout this process, I’ve really been reflecting on that choice I made and how dumb it was. I know I can make a pretty solid program and, instead, I took an easy way out for no good reason. I didn’t want to come in with nothing but, in hindsight, I would have much rather come in with nothing than to disrespect this class the way I did. I have learned a lot in this class and I really appreciate everything that has been done to create an open, accepting, and collaborative culture in this class.
